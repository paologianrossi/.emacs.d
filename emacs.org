* Introduction

Welcome to my emacs configuration.

This should set up emacs as I like it anywhere I need it.

The idea for this configuration (and some of the defuns) are blatantly
stolen or adapted from the [[https://github.com/eschulte/emacs24-starter-kit/][Emacs Starter Kit]].  The main reason why I
do this myself instead of using ESK itself is I want to work a bit
with emacs lisp and I want to set every thing precisely as I mean it.
You should probably use that, anyway.

** Caveats
   + Emacs 24.3 or higher is required.
   + If on the Mac, use a Cocoa version.  This is mostly for keyboard
     issues on non-US keyboards, but also fullscreen and more works
     better on Cocoa.  I just compile emacs with NS, but you could
     also try out [[http://emacsformacosx.com/][Emacs for MacOS X]].

* Implementation
** Portability
   - Here we define predicates for platform detection and harmonization.

     #+begin_src emacs-lisp
       (defun system-macos-p()
           (or (string= window-system "ns") (string= window-system "mac")))
     #+end_src

** Defining where to look for things
    - Emacs uses the =load-path= variable to hold a list of paths
      where to look for libraries.  We set this to hold recursively
      =elisp-dir=, to be able to load extensions we downloaded not
      using [[http://www.emacswiki.org/emacs/ELPA][ELPA]].  We also want to be able to load packages installed
      through ELPA, but this is taken care of [[*ELPA][elsewhere]].
      #+begin_src emacs-lisp
        (add-to-list 'load-path elisp-dir)
        (when (file-exists-p elisp-dir)
          (let ((default-directory elisp-dir))
            (normal-top-level-add-subdirs-to-load-path)))
      #+end_src

    - Various packages need to generate files not for human
      consumption.  We store them in their own directory, =var-dir= to
      avoid cluttering our configs.
      #+begin_src emacs-lisp
        (setq autoload-file (expand-file-name "loaddefs.el" var-dir))
        (setq custom-file (expand-file-name "custom.el" var-dir))
        (setq abbrev-file-name (expand-file-name "abbrev_defs" var-dir))
        (setq bookmark-default-file (expand-file-name "bookmarks" var-dir))
      #+end_src

    - On top of emacs specific stuff, we also need to add
      ~/usr/local/bin~ to the PATH, for better behavior of Emacs in
      various scenarios.

      #+begin_src emacs-lisp
        (add-to-list 'exec-path "/usr/local/bin")
      #+end_src

** Personal info
   - Figure out my username
     #+begin_src emacs-lisp
       (defconst user (getenv "USER"))
     #+end_src

   - Load what is in =./personal/= if it's there.  This is useful to
     avoid having secret stuff leak into public repositories.

     #+begin_src emacs-lisp
       (if (file-exists-p private-dir)
         (dolist (file (directory-files private-dir t "\.\\(el\\|org\\)$"))
           (load-init-file file)))
     #+end_src

** Server
   - Emacs server and client are neat.  You can open many emacs
     windows like instances, but never actually have to reload it.
     This makes for a snappy experience.  We usually start the server
     from the shell, by starting emacs with the following line:
     #+begin_src sh
       emacsclient -a "" -n -c "$@"
     #+end_src

   - When we close emacs (=C-x C-c=), only the terminal is actually
     killed.  If you want to shutdown everything, including the
     server, use the following command (bound to =C-x r q=, memonic: C-x Really Quit):
     #+begin_src emacs-lisp
       (defun server-shutdown ()
         "Save buffers, Quit, and Shutdown (kill) server"
         (interactive)
         (save-some-buffers)
         (kill-emacs))

       (global-set-key (kbd "C-x r q") 'server-shutdown)
     #+end_src

** Packages
   Emacs Packages ELPA is awesome.  However, there are some caveats
   and nuisances.  Here, we try to fix them.

   ELPA packages is the best thing after sliced emacs.  However we want
   all good repos set up.

   - Setup all useful repositories
     #+begin_src emacs-lisp
       (require 'package)

       (setq package-archives
             '(("gnu"         . "http://elpa.gnu.org/packages/")
               ("org"         . "http://orgmode.org/elpa/")
               ("melpa"       . "http://melpa.milkbox.net/packages/")
               ("marmalade"   . "http://marmalade-repo.org/packages/")
               ("elpy"        . "http://jorgenschaefer.github.io/packages/")))

       (package-initialize)
     #+end_src

   - A small nuisance with ELPA is that it does not know by default what we
     want to install.  Let's make it easier to do this: we define
     function: =i-require=.  This works mostly as =require=, except it
     will try to install the package if it cannot be found.

     #+begin_src emacs-lisp
       (defun package-loadable-p (package)
         "Check if PACKAGE is loadable from a directory in `load-path'."
         (let ((load-file (concat (symbol-name package) ".el")))
           (catch 'file-found
             (dolist (dir load-path)
               (let ((path (expand-file-name load-file dir)))
                 (when (file-exists-p path)
                   (throw 'file-found path)))))))

       (defun install-packages-if-needed (&rest packages)
         "Install PACKAGES using ELPA if they are not loadable or installed locally."
         (when packages
           (unless package-archive-contents
             (package-refresh-contents))
           (dolist (package packages)
             (unless (or (package-loadable-p package)
                         (package-installed-p package))
               (package-install package)))))

       (defalias 'install-package-if-needed 'install-packages-if-needed)

       (defun i-require (feature &optional package)
         "Require FEATURE.  If needed, try first to install PACKAGE from ELPA.
       If PACKAGE is not specified, FEATURE is used also as the package name."
         (setq package (or package feature))
         (install-packages-if-needed package)
         (require feature))
#+end_src

** Visuals
   - My favourite theme, right now, is `tango-dark`.  It comes with
     Emacs.
     #+begin_src emacs-lisp
       (load-theme 'tango-dark)
     #+end_src

   - The default font (on a Mac) should be Menlo, size 14, for my taste.
     #+begin_src emacs-lisp
       (add-to-list 'default-frame-alist
                    '(font . "Menlo-14"))
     #+end_src

   - Let's remove useless distractions: make cursor a solid, non-blinking block and remove mouse interfaces.
     #+begin_src emacs-lisp
       (blink-cursor-mode 0)
       (scroll-bar-mode 0)
       (tool-bar-mode 0)
     #+end_src

   - Remove also the menu, but not on the Mac: it's going to be there
     anyway, so it might as well be full-fledged.
     #+begin_src emacs-lisp
       (if (system-macos-p)
           (menu-bar-mode 1)
         (menu-bar-mode 0))
     #+end_src

   - Startup messages are another source of distraction.  Even though
     they happen just once (at startup, duh), we remove them because
     we can.
     #+begin_src emacs-lisp
       (setq initial-scratch-message  "")
       (setq inhibit-startup-message t)
     #+end_src

   (You also want to set =inhibit-startup-echo-area-message= to your
   username.  This needs to be done in Customize to work.  To do it,
   =M-x customize-variable inhibit-startup-echo-area-message= and set
   to your username)

   - While we're at it, let's change the =*scratch*= buffer to be in
     Org-mode instead of Emacs Lisp. To go back to elisp-mode, do =C-c M-l=.

     #+begin_src emacs-lisp
       (setq initial-major-mode 'org-mode)
       (global-set-key (kbd "C-c M-l") 'emacs-lisp-mode)
     #+end_src

   - If we have a title bar, set the frame title to the current file
   (from [[http://emacs-fu.blogspot.co.uk/2011/01/setting-frame-title.html]])
   #+begin_src emacs-lisp
     (setq frame-title-format
           '((:eval (if (buffer-file-name)
                        (abbreviate-file-name (buffer-file-name))
                      "%b"))))
   #+end_src

   - Use the left fringe to show where the file actually ends
     #+begin_src emacs-lisp
       (setq indicate-empty-lines t)
     #+end_src

   - When editing in the minibuffer, don't walk on the prompt.
   (from [[http://ergoemacs.org/emacs/emacs_stop_cursor_enter_prompt.html]])
   #+begin_src emacs-lisp
     (setq minibuffer-prompt-properties (quote (read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt)))
   #+end_src

   - Powerline is a great mode-line customization.  Use it.
     #+begin_src emacs-lisp
       (i-require 'powerline)
       (powerline-center-theme)
       (set-face-foreground 'powerline-active1 "LightGoldenRod")
       (set-face-foreground 'powerline-active2 "#770000")
     #+end_src

   - Yes and no should never be asked graphically (that also makes emacs on the mac explode...)
     #+begin_src emacs-lisp
       (defadvice yes-or-no-p (around prevent-dialog activate)
         "Prevent yes-or-no-p from activating a dialog"
         (let ((use-dialog-box nil))
           ad-do-it))
       (defadvice y-or-n-p (around prevent-dialog-yorn activate)
         "Prevent y-or-n-p from activating a dialog"
         (let ((use-dialog-box nil))
           ad-do-it))
     #+end_src

** Editing and navigation
*** Fix scroll/unscroll
    Sometimes i =C-v= while wanting to =C-b=.  If that happens,
    =C-S-v= sends me back to before scrolling.  The same applies to
    =M-v= / =M-S-v= (and unscrolling is independent of the key: you
    can uscroll a =M-v= with =C-S-v=).

    This comes from the very old and very good Giraffe Book (Writing
    GNU Emacs Extensions) by Bob Glickstein.

    #+begin_src emacs-lisp
      (defvar unscroll-point (make-marker) "Text position for `unscroll'.")
      (defvar unscroll-window-start (make-marker) "Text position for `unscroll'.")

      (put 'scroll-up-command 'unscrollable t)
      (put 'scroll-down-command 'unscrollable t)

      (defun unscroll-maybe-remember ()
        (if (not (get last-command 'unscrollable))
            (progn (set-marker unscroll-point (point))
                   (set-marker unscroll-window-start (window-start)))))


      (defadvice scroll-up (before remember-for-unscroll activate compile)
        "Remember where we come from when scrolling."
        (unscroll-maybe-remember))

      (defadvice scroll-down (before remember-for-unscroll activate compile)
        "Remember where we come from when scrolling."
        (unscroll-maybe-remember))

      (defun unscroll ()
        "Jump to location defined by `unscroll-to'."
        (interactive)
        (if (not unscroll-point)
            (error "Can't unscroll"))
        (goto-char unscroll-point)
        (set-window-start nil unscroll-window-start))

      (global-set-key (kbd "C-S-v") 'unscroll)
      (global-set-key (kbd "M-S-v") 'unscroll)
    #+end_src

*** Goto last change
    #+begin_src emacs-lisp
      (i-require 'goto-chg)
      (global-set-key (kbd "C-.") 'goto-last-change)
      (global-set-key (kbd "C-,") 'goto-last-change-reverse)
    #+end_src

*** Better goto-line
   #+begin_src emacs-lisp
     (global-set-key [remap goto-line] 'goto-line-with-feedback)

     (defun goto-line-with-feedback ()
       "Show line numbers temporarily, while prompting for the line number input"
       (interactive)
       (unwind-protect
           (progn
             (linum-mode 1)
             (goto-line (read-number "Goto line: ")))
         (linum-mode -1)))
   #+end_src

*** Lines

      | Functionality                             | Binding            | Mnemonic           |
      |-------------------------------------------+--------------------+--------------------|
      | newline and indent                        | C-j, C-<RET>       | "fatter" return    |
      | open line above current line (and indent) | C-S-j, C-S-<RET>   | As above, but "up" |
      | drag line or lines of region up/down      | M-<up>/M-<down>    |                    |
      | drag word or region left/right            | M-<left>/M-<right> |                    |

   #+begin_src emacs-lisp
     (defun open-line-above ()
       "Insert indented line *above* current line."
       (interactive)
       (beginning-of-line)
       (newline)
       (forward-line -1)
       (indent-for-tab-command))

     (global-set-key (kbd "<C-return>") 'newline-and-indent)
     (global-set-key (kbd "<C-S-return>") 'open-line-above)
     (global-set-key (kbd "C-S-j") 'open-line-above)

     (i-require 'drag-stuff)
     (add-to-list 'drag-stuff-except-modes 'org-mode)
     (drag-stuff-global-mode 1)

     (global-set-key (kbd "M-j")
                     (lambda ()
                       (interactive)
                       (join-line -1)))
   #+end_src

*** Undo/redo
    - Use =undo-tree-mode=

    #+begin_src emacs-lisp
      (i-require 'undo-tree)
      (global-undo-tree-mode)
    #+end_src

*** Buffers
    - Operations on the file visited by current buffer

      | Functionality            | Binding | Mnemonic |
      |--------------------------+---------+----------|
      | Rename buffer and file   | C-x C-r | 'r'ename |
      | Delete buffer and file   | C-x C-k | 'k'ill   |

    #+begin_src emacs-lisp
      (defun rename-current-buffer-file ()
        "Renames current buffer and file it is visiting."
        (interactive)
        (let ((name (buffer-name))
              (filename (buffer-file-name)))
          (if (not (and filename (file-exists-p filename)))
              (error "Buffer '%s' is not visiting a file!" name)
            (let ((new-name (read-file-name "New name: " filename)))
              (if (get-buffer new-name)
                  (error "A buffer named '%s' already exists!" new-name)
                (rename-file filename new-name 1)
                (rename-buffer new-name)
                (set-visited-file-name new-name)
                (set-buffer-modified-p nil)
                (message "File '%s' successfully renamed to '%s'"
                         name (file-name-nondirectory new-name)))))))


      (defun delete-current-buffer-file ()
        "Removes file connected to current buffer and kills buffer."
        (interactive)
        (let ((filename (buffer-file-name))
              (buffer (current-buffer))
              (name (buffer-name)))
          (if (not (and filename (file-exists-p filename)))
              (ido-kill-buffer)
            (when (yes-or-no-p "Are you sure you want to remove this file? ")
              (delete-file filename)
              (kill-buffer buffer)
              (message "File '%s' successfully removed" filename)))))

      (global-set-key (kbd "C-x C-r") 'rename-current-buffer-file)
      (global-set-key (kbd "C-x C-k") 'delete-current-buffer-file)

    #+end_src

*** Encoding

    Setup the system to work in Unicode UTF-8 as much as we can.
    #+begin_src emacs-lisp
      (set-terminal-coding-system 'utf-8)
      (set-keyboard-coding-system 'utf-8)
      (prefer-coding-system 'utf-8)
    #+end_src

*** Misc
    Various micro-enhancements.  We could find a better location in this file, but they are here for now.

    - Never ask for the long 'yes'/'no' form.  Stick to 'y'/'n';
    - Indent with 4 spaces instead of tabs;
    - =C-w= and =M-w= copy/kill the current line if no region is selected;
    - When saving, delete all trailing whitespace and ensure there is always a newline at the end of the file;
    - When moving at beginning of the line (C-a): on first call go to indentation, on next call go to actual BOL;
    - Enable narrowing and horizontal scrolling;

    #+begin_src emacs-lisp
      (defalias 'yes-or-no-p 'y-or-n-p)

      (setq-default indent-tabs-mode nil
                    tab-width 4)

      ;; http://emacs-fu.blogspot.hk/2009/11/copying-lines-without-selecting-them.html
      (defadvice kill-ring-save (before slick-copy activate compile)
        "When called interactively with no active region, copy a single line instead."
        (interactive
         (if mark-active
             (list (region-beginning) (region-end))
           (message "Copied line")
           (list (line-beginning-position) (line-beginning-position 2)))))

      (defadvice kill-region (before slick-cut activate compile)
        "When called interactively with no active region, kill a single line instead."
        (interactive
         (if mark-active (list (region-beginning) (region-end))
           (list (line-beginning-position)
                 (line-beginning-position 2)))))

      (add-hook 'write-file-hooks 'delete-trailing-whitespace)

      (setq require-final-newline t)

      (defadvice move-beginning-of-line (around smarter-bol activate)
        ;; Move to requested line if needed.
        (let ((arg (or (ad-get-arg 0) 1)))
          (when (/= arg 1)
            (forward-line (1- arg))))
        ;; Move to indentation on first call, then to actual BOL on second.
        (let ((pos (point)))
          (back-to-indentation)
          (when (= pos (point))
            ad-do-it)))

      ;; Enable narrowing
      (put 'narrow-to-defun 'disabled nil)
      (put 'narrow-to-page 'disabled nil)
      (put 'narrow-to-region 'disabled nil)

      ;; Enable scrolling
      (put 'scroll-left 'disabled nil)

    #+end_src

*** MacOS X specific configuration
    If we are on a mac, we have some specific configuration.
**** Setup modifiers
     We want CMD Meta, Fn Hyper, left-option (left-alt) Super, right-option (right-alt) Alt.

     #+begin_src emacs-lisp
       (setq mac-command-modifier 'meta)
       (setq mac-option-modifier 'super)
       (setq ns-function-modifier 'hyper)

         ;;; if on the Mac, right alt should be alt (not meta, super, hyper
         ;;; or whatever). This is because I still want to use deadkeys.
       (setq mac-right-option-modifier nil)
     #+end_src
**** Show file in Finder
     #+begin_src elisp
       ;; reveal-in-finder 2014-02-02
       ;; Original: http://stackoverflow.com/questions/20510333/in-emacs-how-to-show-current-file-in-finder
       ;; Modified version
       (defun reveal-in-finder ()
         (interactive)
         (let ((path (buffer-file-name))
               dir file)
           (if path
               ;; if path has been successfully obtained.
               (progn (setq dir (file-name-directory path))
                      (setq file (file-name-nondirectory path)))
             ;; if path is empty, there is no file name. Use the default-directory variable
             (setq dir (expand-file-name default-directory))
             )
           ;; (message (concat "Opening in Finder: " dir file))  ; Show the file name
           (reveal-in-finder-1 dir file)
           ))
       ;;
       (defun reveal-in-finder-1 (dir file)
         (let ((script
                (if file
                    (concat
                     "set thePath to POSIX file \"" (concat dir file) "\"\n"
                     "tell application \"Finder\"\n"
                     " set frontmost to true\n"
                     " reveal thePath \n"
                     "end tell\n"
                     )
                  (concat
                   "set thePath to POSIX file \"" (concat dir) "\"\n"
                   "tell application \"Finder\"\n"
                   " set frontmost to true\n"
                   " reveal thePath \n"
                   "end tell\n"))))
           ;; (message script)   ; Show the script in the mini-buffer
           (start-process "osascript-getinfo" nil "osascript" "-e" script)
           ))

       (if (system-macos-p)
           (global-set-key (kbd "C-x M-f") 'reveal-in-finder))
     #+end_src

** Fullscreen
   - Cycle to "fullscreen" states without the mouse.  Loop in this order:
     - =normal=
     - =maximized=
     - =fullboth= (fullscreen-like)
     - =fullwidth=
     - =fullheight=

     #+begin_src emacs-lisp
       (defun cycle-fullscreen ()
         (interactive)
         (let ((flow '((nil . 'maximized) (maximized . 'fullboth)
                       (fullboth . 'fullwidth) (fullwidth . 'fullheight)
                       (fullheight . nil))) (current (frame-parameter nil 'fullscreen)))
           (set-frame-parameter nil 'fullscreen (car (cdr (assoc-default current flow nil nil))))
           ))

       (global-set-key (kbd "<s-return>") 'cycle-fullscreen)
     #+end_src

** Bell
   - The bell is annoying.  If it dings, it bothers the world and me.
     If it doesn't (low volume, headphones in, whatever), it's
     useless.  I'd like to make it visual, but on the Mac,
     unfortunately, the bell is an ugly white square in the middle of
     the frame.  Here, we make it less conspicuous by flipping the
     mode-line.
     #+begin_src emacs-lisp
       (defun my-terminal-visible-bell ()
         "A friendlier visual bell effect."
         (invert-face 'mode-line)
         (run-with-timer 0.1 nil 'invert-face 'mode-line))

       (setq visible-bell nil
             ring-bell-function 'my-terminal-visible-bell)
     #+end_src

** Backup files and autosave
   Emacs backs everything up.  By default, backup files are those
   annoying suffixed-in-~ files you find in the original file's
   directory.  Here we configure backups to be better behaved than
   default, without disabling them as they're actually pretty useful.
   #+begin_src emacs-lisp
     (setq
      backup-directory-alist `(("." . ,(expand-file-name
                                        (concat user-emacs-directory "backups"))))
      backup-by-copying t
      delete-old-versions t
      kept-new-versions 20
      kept-old-versions 2
      vc-make-backup-files t
      version-control t)
   #+end_src

   Auto-saves are a totally different beast.  They're even more useful
   than backups when it hits the fan.  Since they are not to be used
   by humans, we store them in =var-dir=.  Also, we trigger a backup
   every time we autosave, and set some sensible thresholds for autosaving.
   #+begin_src emacs-lisp
     (setq
      auto-save-list-file-prefix (expand-file-name "aut-save-list/.saves-" var-dir)
      auto-save-timeout 10
      auto-save-interval 300)

     (add-hook 'auto-save-hook (lambda () (setq buffer-backed-up nil)))
   #+end_src

** Save places
   - Remember where we left off for each file.  When we reopen the file, bring us to the right place.
     #+begin_src emacs-lisp
       (require 'saveplace)
       (setq-default save-place t)
       (setq save-place-file (expand-file-name "saved-places" var-dir))
     #+end_src

** Auto-reverting
   - If a file changes on disk, refresh it in emacs too.
     #+begin_src emacs-lisp
       (global-auto-revert-mode 1)
     #+end_src

   - Also auto refresh dired, but be quiet about it
     #+begin_src emacs-lisp
       (setq global-auto-revert-non-file-buffers t)
       (setq auto-revert-verbose nil)
     #+end_src

** TODO Keybindings
#+name: keybindings
#+begin_src emacs-lisp
  ;; Activate occur easily inside isearch
  (define-key isearch-mode-map (kbd "C-o") 'isearch-occur)

  (global-set-key (kbd "C-x C-b") 'ibuffer)

  ;; Use hippie-expand instead of dabbrev
  (global-set-key (kbd "M-/") 'hippie-expand)

  (global-set-key (kbd "C-h C-f") 'find-function)

  (global-set-key (kbd "M-p") 'magit-find-file-completing-read)

  ;; terminal-related bindings

  ;; Really quit emacs

#+end_src

** Window management
   Using multiple frames and windows, especially also using
   emacsclient, is pretty powerful.  Let's make it easy to work with.

   - Function =detach-window= pulls a window out in a new frame.
     #+begin_src emacs-lisp
       (defun detach-window (&optional window)
         (interactive)
         (set-buffer (window-buffer window))
         (let ((old-frame (selected-frame))
               (new-frame (make-frame)))
           (select-frame old-frame)
           (delete-window window)
           (select-frame new-frame)
           ))
     #+end_src

   - Ace window for fast window selection
     #+begin_src elisp
       (i-require 'ace-window)
     #+end_src

   - Window key bindings (note that "window" and "frame" are used in
     the Emacs sense):

     | Functionality             | Binding      | Mnemonic                                                                     |
     |---------------------------+--------------+------------------------------------------------------------------------------|
     | Focus on other frame      | =M-`=        | As in WM                                                                     |
     | Delete this frame         | =s-w s-w=    | Cmd-W in MacOS closes windows                                                |
     | Create a frame            | =s-w s-n=    | 'n' for "new frame"                                                          |
     | Detach window             | =s-w s-d=    | 'd' for "detach"                                                             |
     | Close window              | =s-w w=      | 'w' for closing (see above), but without modifiers since a window is lighter |
     | Split window horizontally | =s-w -=      | Split along an horizontal line ('-')                                         |
     | Split window vertically   | =s-w <pipe>= | Split along a vertical line                                                  |
     | Keep only current window  | =s-w W=      | Capitalized 'W' is for closing other things                                  |
     | Keep only current frame   | =s-w s-W=    | Capitalized 'W' is for closing other things                                  |
     | Balance windows           | =s-w +=      | Usually bound to =C-x +=                                                     |
     | Open file in new window   | =s-w f=      | 'f' for file as in =C-x f=                                                   |
     | Open file in new frame    | =s-w F=      | 'f' for file as in =C-x f=, but capitalized because frames are heavy         |
     | Jump to window            | =s-w j=      | 'j' for jump                                                                 |

     #+begin_src emacs-lisp
       (global-set-key (kbd "M-`") 'other-frame)
       (define-prefix-command 'window-management-map)
       (global-set-key (kbd "s-w") 'window-management-map)
       (define-key window-management-map (kbd "s-w") 'delete-frame)
       (define-key window-management-map (kbd "s-n") 'make-frame-command)
       (define-key window-management-map (kbd "s-d") 'detach-window)
       (define-key window-management-map (kbd "w") 'delete-window)
       (define-key window-management-map (kbd "-") 'split-window-below)
       (define-key window-management-map (kbd "|") 'split-window-right)
       (define-key window-management-map (kbd "W") 'delete-other-windows)
       (define-key window-management-map (kbd "s-W") 'delete-other-frames)
       (define-key window-management-map (kbd "+") 'balance-windows)
       (define-key window-management-map (kbd "f") 'find-file-other-window)
       (define-key window-management-map (kbd "F") 'find-file-other-frame)
       (define-key window-management-map (kbd "j") 'ace-window)
     #+end_src

   - Keep history of windows layouts and undo/redo them with =C-c <left>= and =C-c <right>=
     #+begin_src emacs-lisp
       (winner-mode 1)
     #+end_src

** Terminal
   I like to have a terminal inside Emacs: it is fun and useful.
   We use =ansi-term= here, as it integrates better than =shell= or
   =eshell=.

   - Open the terminal (with prefix, reset it too)
     #+begin_src emacs-lisp
       (defun do-open-term (&optional arg)
         "Opens an ansi-term with value of $SHELL - force new ansi-term
       with prefix"
         (interactive "p")
         (if (or (not (get-buffer "*ansi-term*")) (= arg 4))
             (ansi-term (getenv "SHELL"))
           (switch-to-buffer "*ansi-term*")))
     #+end_src

   - Close term buffer when we're done with it
     #+begin_src emacs-lisp
       (defun comint-delchar-or-eof-or-kill-buffer (arg)
         (interactive "p")
         (if (null (get-buffer-process (current-buffer)))
             (kill-buffer)
           (comint-delchar-or-maybe-eof arg)))

       (add-hook 'shell-mode-hook
                 (lambda ()
                   (define-key shell-mode-map
                     (kbd "C-d") 'comint-delchar-or-eof-or-kill-buffer)))

       (defun kill-buffer-when-shell-command-exit ()
         "Close current buffer when `shell-command' exit."
         (let ((process (ignore-errors (get-buffer-process (current-buffer)))))
           (when process
             (set-process-sentinel process
                                   (lambda (proc change)
                                     (when (string-match "\\(finished\\|exited\\Debugger\\)" change)
                                       (kill-buffer (process-buffer proc)))))))
         )

       (add-hook 'term-mode-hook 'kill-buffer-when-shell-command-exit)
     #+end_src

   - Miscellaneous terminal configuration
     #+begin_src emacs-lisp
       (defun term-my-hook ()
                 (interactive)
                 (make-local-variable 'mouse-yank-at-point)
                 (make-local-variable 'transient-mark-mode)
                 (auto-fill-mode -1)
                 (compilation-shell-minor-mode t)
                 (setq mouse-yank-at-point t
                       term-scroll-to-bottom-on-output nil
                       term-scroll-show-maximum-output nil
                       term-buffer-maximum-size 1024
                       transient-mark-mode nil
                       tab-width 8))

       (add-hook 'term-mode-hook 'term-my-hook)
     #+end_src

   - We might use =multi-term= when we want more than one open terminal
     #+begin_src emacs-lisp
       (i-require 'multi-term)
     #+end_src

   - Keybindings

     | Functionality                                          | Binding | Mnemonic                    |
     |--------------------------------------------------------+---------+-----------------------------|
     | Open terminal (or create new if needed or if prefixed) | =s-t=   | 't' for terminal            |
     | Open new separate terminal via =multi-term=            | =s-T=   | 'T' for fat, multi terminal |

     #+begin_src emacs-lisp
       (global-set-key (kbd "s-t") 'do-open-term)
       (global-set-key (kbd "s-T") 'multi-term)
     #+end_src

** IDO
   #+begin_src emacs-lisp
     (require 'ido)
     (setq ido-save-directory-list-file (expand-file-name "ido-last" var-dir))

      (ido-mode 1)
      (install-packages-if-needed 'ido-ubiquitous)
      (i-require 'flx-ido)
      (flx-ido-mode 1)
      (setq ido-use-faces nil)

      (ido-ubiquitous-mode 1)

      ;; Fix ido-ubiquitous for newer packages
      (defmacro ido-ubiquitous-use-new-completing-read (cmd package)
        `(eval-after-load ,package
           '(defadvice ,cmd (around ido-ubiquitous-new activate)
              (let ((ido-ubiquitous-enable-compatibility nil))
                ad-do-it))))

      (ido-ubiquitous-use-new-completing-read webjump 'webjump)
      (ido-ubiquitous-use-new-completing-read yas/expand 'yasnippet)
      (ido-ubiquitous-use-new-completing-read yas/visit-snippet-file 'yasnippet)

     ;; Display ido results vertically, rather than horizontally
      (setq ido-decorations (quote ("\n-> " "" "\n   " "\n   ..." "[" "]" " [No match]" " [Matched]" " [Not readable]" " [Too big]" " [Confirm]")))
      (defun ido-disable-line-truncation () (set (make-local-variable 'truncate-lines) nil))
      (add-hook 'ido-minibuffer-setup-hook 'ido-disable-line-truncation)
      (defun ido-define-keys () ;; C-n/p is more intuitive in vertical layout
        (define-key ido-completion-map (kbd "C-n") 'ido-next-match)
        (define-key ido-completion-map (kbd "C-p") 'ido-prev-match))
      (add-hook 'ido-setup-hook 'ido-define-keys)

      (add-hook 'ido-setup-hook
                (lambda ()
                  ;; Go straight home
                  (define-key ido-file-completion-map
                    (kbd "~")
                    (lambda ()
                      (interactive)
                      (if (looking-back "/~")
                          (insert "/")
                        (call-interactively 'self-insert-command))))))

      (defun djcb-find-file-as-root ()
        "Like `ido-find-file, but automatically edit the file with
               root-privileges (using tramp/sudo), if the file is not writable by
               user."
        (interactive)
        (let ((file (ido-read-file-name "Edit as root: ")))
          (unless (file-writable-p file)
            (setq file (concat "/sudo:root@localhost:" file)))
          (find-file file)))
      ;; or some other keybinding...
      (global-set-key (kbd "C-x F") 'djcb-find-file-as-root)
   #+end_src

   - Use idomenu to navigate within the buffer.  I don't use etags, usually, so I bind =M-.= to this.
     #+begin_src emacs-lisp
       (i-require 'idomenu)
       (global-set-key (kbd "M-.") 'idomenu)
     #+end_src

** SMEX
   Smex is a =M-x= enhancement for Emacs.  It provides a convenient [[*IDO][IDO]] based
   interface to your recently and most frequently used commands.
   #+begin_src emacs-lisp
     (i-require 'smex)
     (smex-initialize)
     (setq smex-save-file (expand-file-name ".smex-items" var-dir))
     (global-set-key (kbd "M-x") 'smex)
     (global-set-key (kbd "M-X") 'smex-major-mode-commands)

     ;; This is your old M-x.
     (global-set-key (kbd "C-x x") 'execute-extended-command)
   #+end_src
** TODO Dired
   #+begin_src emacs-lisp
     (require 'dired)

     (setq dired-use-ls-dired 'unspecified)

     (install-packages-if-needed 'dired-details)
     (i-require 'dired-details)
     (i-require 'dired+)
     (i-require 'dired-details+)

     (setq-default dired-details-hidden-string "--- ")
     (dired-details-install)

     (setq
      dired-omit-verbose t
      dired-dwim-target t
      dired-recursive-copies 'top
      dired-recursive-deletes 'top
     )

     (defun dired-back-to-top ()
       (interactive)
       (beginning-of-buffer)
       (dired-next-line 4))

     (define-key dired-mode-map
       (vector 'remap 'beginning-of-buffer) 'dired-back-to-top)

     (define-key dired-mode-map
       (kbd "e")
       (lambda () (interactive)
         (dired-do-shell-command "open" nil (dired-get-marked-files))))

     (defun dired-jump-to-bottom ()
       (interactive)
       (end-of-buffer)
       (dired-next-line -1))

     (define-key dired-mode-map
       (vector 'remap 'end-of-buffer) 'dired-jump-to-bottom)
#+end_src

** Searching and replacing
   - Show number of matches in the modeline

     #+begin_src emacs-lisp
       (i-require 'anzu)
       (global-anzu-mode 1)
       (set-face-attribute 'anzu-mode-line nil
                           :foreground "#770000" :weight 'bold)

       (setq anzu-mode-lighter "")
       (setq anzu-deactivate-region t)
       (setq anzu-search-threshold 1000)
       (setq anzu-replace-to-string-separator " => ")

       (define-prefix-command 'replace-map)
       (global-set-key (kbd "M-%") 'replace-map)
       (define-key replace-map (kbd "%") 'anzu-query-replace)
       (define-key replace-map (kbd "M-%") 'anzu-query-replace-regexp)
       (define-key replace-map (kbd ".") 'anzu-query-replace-at-cursor)
       (define-key replace-map (kbd ">") 'anzu-query-replace-at-cursor-thing)
     #+end_src

** Version Control
   Magit is the best way to manage git repositories from emacs.

   Switching to Magit will open the status window as the only window
   in the frame.  Quitting will restore windows.

   #+begin_src emacs-lisp
     (i-require 'magit)
     (i-require 'magit-find-file)

     (defadvice magit-status (around magit-fullscreen activate)
       (window-configuration-to-register :magit-fullscreen)
       ad-do-it
       (delete-other-windows))

     (global-set-key (kbd "C-x g") 'magit-status)

     (defun magit-quit-session ()
       "Restores the previous window configuration and kills the magit buffer"
       (interactive)
       (kill-buffer)
       (jump-to-register :magit-fullscreen))

     (defun magit-toggle-whitespace ()
       (interactive)
       (if (member "-w" magit-diff-options)
           (magit-dont-ignore-whitespace)
         (magit-ignore-whitespace)))

     (defun magit-ignore-whitespace ()
       (interactive)
       (add-to-list 'magit-diff-options "-w")
       (magit-refresh))

     (defun magit-dont-ignore-whitespace ()
       (interactive)
       (setq magit-diff-options (remove "-w" magit-diff-options))
       (magit-refresh))

     (define-key magit-status-mode-map (kbd "W") 'magit-toggle-whitespace)

     (defun magit-just-amend ()
       (interactive)
       (save-window-excursion
         (magit-with-refresh
           (shell-command "git --no-pager commit --amend --reuse-message=HEAD"))))

     (eval-after-load "magit"
       '(define-key magit-status-mode-map (kbd "C-c C-a") 'magit-just-amend))

   #+end_src

** TODO Autocomplete
#+name: autocomplete
#+begin_src emacs-lisp

  (i-require 'auto-complete)
  (require 'auto-complete-config)
  (setq ac-ignore-case nil)
  (setq ac-comphist-file (expand-file-name "ac-comphist.dat" var-dir))
  (setq-default ac-sources '(ac-source-abbrev
                             ac-source-dictionary
                             ac-source-words-in-same-mode-buffers))
  (ac-config-default)
  (global-auto-complete-mode t)
#+end_src
** Tramp
   With tramp, you can edit remote files as if they were local.

   If you add this to a remote server, in your .zshrc or the like,
   then magic will happen: ssh to that server from the [[*Terminal][Terminal]]; cd
   wherever on the remote host in the terminal; =C-x C-f= will show
   the prefilled path to the right remote directory.

   #+begin_src sh
     # setup things for emacs-tramp
     if [ "$TERM" = "xterm-256color" ]; then # You might need to change this depending on your $TERM value
       precmd() {
             echo -e "\033AnSiTu" "$LOGNAME" # $LOGNAME is more portable than using whoami.
             echo -e "\033AnSiTc" "$(pwd)"
             if [ $(uname) = "SunOS" ]; then
             # The -f option does something else on SunOS and is not needed anyway.
                 hostname_options="";
             else
                 hostname_options="-f";
             fi
             echo -e "\033AnSiTh" "$(hostname $hostname_options)" # Using the -f option can
                                                                  # cause problems on some OSes.
         }
     fi
   #+end_src

   - Use local-to-var paths for tramp tmp files.
   #+begin_src emacs-lisp
     (setq tramp-persistency-file-name (expand-file-name "tramp" var-dir))
     (setq tramp-auto-save-directory (expand-file-name "tramp-autosave/" var-dir))
   #+end_src

** FlyMake
   FlyMake performs on-the-fly syntax checks on the files being edited
   using the external syntax check tool (usually the
   compiler). Highlights erroneous lines and displays associated error
   messages.

   #+begin_src emacs-lisp
     (i-require 'flymake)
     (i-require 'rfringe)
     (i-require 'flycheck)
     (global-flycheck-mode)
   #+end_src

** Yasnippet
   - Load globally the completion snippets
     #+begin_src emacs-lisp
       (i-require 'yasnippet)
       (yas-load-directory (expand-file-name "snippets/" dotfiles-dir) t)
       (yas-global-mode 1)
       (i-require 'auto-yasnippet)
     #+end_src
** Bookmarks and Registries
   Bookmarks and registries are good ways to remember positions etc.
   #+begin_src emacs-lisp
     (require 'bookmark)
     (i-require 'bookmark+)

      (defun ido-bookmark-jump (bname)
       "*Switch to bookmark interactively using `ido'."
       (interactive (list (ido-completing-read "Bookmark: " (bookmark-all-names) nil t)))
       (bookmark-jump bname))
     (global-set-key (kbd "s-b") 'bookmark-set)
     (global-set-key (kbd "s-B") 'ido-bookmark-jump)
   #+end_src

** Statistics
   Collect statistics on commands etc. to have data for optimizing my
   config. Use =M-x keyfreq-show= to see stats.
   #+begin_src emacs-lisp
     (i-require 'keyfreq)
     (keyfreq-mode 1)
     (keyfreq-autosave-mode 1)
   #+end_src

** Smartparens
   #+begin_src emacs-lisp
     (load-init-file "smartparens")
   #+end_src

** Email
   Email in Emacs!
   #+begin_src emacs-lisp
     (load-init-file "email")
   #+end_src
** Text-mode
   Configuration for editing text (as opposed to source code editing) has its own config file [[file:text-mode.org::*Text%20Modes%20configuration][here]].
   #+begin_src emacs-lisp
     (load-init-file "text-mode")
   #+end_src
** Prog-mode
   Configuration for editing code has its own config file [[file:prog-mode.org::*Prog-mode%20configuration][here]].

   #+begin_src emacs-lisp
     (load-init-file "prog-mode")
   #+end_src

** Python-mode
   For Python, I use Elpy.  I think I will make this myself (getting
   inspired from elpy and friends), to refactor out
   programming-related configs into a more generic, reusable file.
   #+begin_src emacs-lisp
     (i-require 'elpy)
       (elpy-enable)
       (define-key yas-minor-mode-map (kbd "C-c k") 'yas-expand)
     (define-key global-map (kbd "C-c o") 'iedit-mode)
   #+end_src

** Ruby-mode
   Load my Ruby config
   #+begin_src emacs-lisp
     (load-init-file "ruby")
   #+end_src
** Fun
   Sometimes it's good to have a little fun.
*** Read XKCD from Emacs
    call =(xkcd-get-latest)= (=M-x xkcd-get-latest=) for the latest xkcd comic.
    #+begin_src emacs-lisp
      (i-require 'xkcd)
      (setq xkcd-cache-dir (expand-file-name "xkcd/" var-dir))
    #+end_src
** Customize
   Last thing is load customizations.  This goes last to allow user overridings through customize.
   #+begin_src emacs-lisp
     (if (file-exists-p custom-file) (load custom-file))
   #+end_src
